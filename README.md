# pro-demo
a simple demo of how to use [pro](https://github.com/forax/pro)

## Foreword 

before starting, be sure to have pro in your PATH,
```
  export PATH=$PATH:/path/to/pro/bin/pro
```

# A simple modular application

Let say we want to create a simple application that is able to print some messages.
These messages can be printed on the console, using a logger, etc, so we want to be able at deployment time to choose which kind of of Printer should be used.

For the demo, let's pretend that it's a good idea to define 3 modules
 - the main module printer.main, which contains the main
 - the API module printer.api, which defines the interface Printer
 - the factory module printer.logger that provide one implementation of the Printer interface using the java.logging API.
 
On disk, the layout is the following
```
 src
   main
     java
       printer.main        <- module name
         com
           acme
             printer
               main        <- package name
                 Main.java
       printer.api         
         com    
           acme
             printer
               api
                 Printer.java
       printer.logger
         com
           acme
             printer
               logger
                 PrinterFactory         
```
the folder src/main/java contains the 3 modules printer.main, printer.api and printer.logger

## Module printer.api

The module-info.java defines the modules required (using the directive requires) and the package exported (using the directive exports).

Here, there is no module required (java.base is required by default) so the module-info.java only contains one directive exports
```
module printer.api {
  exports com.acme.printer.api;
}
```

## Module printer.main

Again, the module-info defines the module requires and the packages exported.
Here, printer.main use the interface com.acme.printer.api.Printer so it requires printer.api, the module that contains the package com.acme.printer.api.
We do not declare the package com.acme.printer.main as exported, so it will be non visible for the other module.

Furthermore, we use the service mechanism provided by the module. If a module declare a directive use with an interface,
it can use the class java.util.ServiceLoader to discover at runtime all the implementations of the service.

So here, the Main class will use the ServiceLoader with the interface com.acme.printer.api.Printer.
```
module printer.main {
  requires printer.api;
  
  uses com.acme.printer.api.Printer;
}
```

## Module printer.logger

Here, we want to implements the interface Printer which is defined in the module printer.api and we want to implement it with java.util.logging API,
defined in the module java.logging. So the module-info requires java.logging and printer.api.
We also want the class com.acme.printer.logger.PrinterFactory to be visible by the other modules, so we declare the package com.acme.printer.logger as exported.

Because, we export the class com.acme.printer.logger.PrinterFactory and this class has a public method (provider) that uses a type from the module printer.api,
we declare printer.api with the directive requires transitive so if a module requires printer.logger, it will not have to also requires printer.api.  

This module provide an implementation of the service com.acme.printer.api.Printer, so we use the directive provides to indicate the class
com.acme.printer.logger.PrinterFactory that will act as a factory that provides an implementation of the interface com.acme.printer.api.Printer.
```
module printer.logger {
  requires java.logging;
  requires transitive printer.api;
  
  exports com.acme.printer.logger;
  
  provides com.acme.printer.api.Printer
    with com.acme.printer.logger.PrinterFactory;
}
```

# Using the REPL

Perhaps the simplest way to use pro is to use is to use its REPL,
```
$ pro shell
```

by default you need to import all the commands of pro that are defined as function inside the class com.github.forax.pro.Pro
```
jshell> import static com.github.forax.pro.Pro.*
```

now, you can use the function run to run the different plugins of pro, by exemple
```
jshell> run("compiler")
```
will run the java compiler on all the sources inside the folder src/main/java.

The result on your console should be something like that
```
[pro] registered plugins compiler, convention, linker, modulefixer, packager, resolver, uberpackager
[pro] DONE !          elapsed time 1,064 ms
  
```
The classes of the modules generated by the compiler are stored in target/src/exploded.
From the REPL, you can get all the class files using the function files
```
jshell> files(location("target/src/exploded"), perlRegex(".*\\.class"))  
``` 

The result is a Java list of all paths inside the folder printer.main 
```
$3 ==> [target/src/exploded/printer.logger/module-info.class, target/src/exploded/printer.logger/com/acme/printer/logger/PrinterFactory.class, ..., target/src/exploded/printer.api/com/acme/printer/api/Printer.class]
```

Now, instead of just compiling, we can compile and packages all the classes in module jars
```
jshell> run("compiler", "packager")
```

The result is stored in folder target/src/artifact
```
jshell> files(location("target/src/artifact"))
$6 ==> [target/src/artifact, target/src/artifact/printer.logger-1.0.jar, target/src/artifact/printer.main-1.0.jar, target/src/artifact/printer.api-1.0.jar]
```

If we want to run the application, we first need to declare the version of the module and which module declares a main class by seeting the packager.moduleMetadata 
```
set("packager.moduleMetadata", list("printer.main@1.0/com.acme.printer.main.Main"))
```

And then re-package the application and run it
```
jshell> run("compiler", "packager", "runner")

```

Congratulation, you have run your first modular application with pro !

To exit the shell
```
\exit
```

# Using the command line

You can record all the build information info one json file named build.json
```
{
  packager: {
    moduleMetadata: [
      "printer.main@1.0/com.acme.printer.main.Main",
      "printer.api@1.0",
      "printer.factory@1.0",
    ]
  },
  run: ["compiler", "packager", "runner"]
}
```

And just run it
```
$ pro 
```

